# -*- coding: utf-8 -*-
"""Present Testing Version of DNQ Algorithim.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HdXU03sEj55O0DU8B-hV_7r7ITZq27GN
"""

#import libraries
import pandas as pd
import numpy as np

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import random
from collections import deque
import json
import numpy as np
import math

import matplotlib.pyplot as plt
from matplotlib.patches import Circle
import time

# set up matplotlib

"""Preprocess the inported learning file"""

# open the file in panda
data = pd.read_csv("Desktop/Mehta+_Final_Project/30_increment_file1_cart.csv")
state_name = ["time", "thrust", "mass", "acceleration x", "acceleration y", "speed x", "speed y", "flight angle", "pitch angle", "degree position", "height", "downrange distance", "position x", "position y"]
data = data.dropna()

# get the present states
present_state = data[["present " + x for x in state_name]].to_numpy()

pitch_angle_reference_angle = [math.radians(-30), math.radians(0), math.radians(30)]

target_pitch_angle_list = data["pitch angle"]

# # get the next states
next_state_array = data[["next " + x for x in state_name]].to_numpy()

orbital_param_data = [227324.6148992991, 3859163.1623380445, 0.2158149083574382]

data

"""Reward Function"""

class Reward:
  '''The reward function for the Deep-Q Network of rocket '''


  def __init__(self):
        '''Reward() -> Reward
        initalizes the reward for a function'''
        self.total_reward = 0
        self.change_amount = 0

  def intermediate_reward(self, state, action, previous_action_list, orbital_characteristic):
        present_reward = 0
        # perigee, apogee = orbital_characteristic[:2]

        # # reward for pitch angle


        # # Reward for height, scaled appropriately
        # height = state[5]
        # # height_reward = min(height, 30000) * 0.005 / 30000  # max reward 0.05
        # # present_reward += height_reward

        # # Reward for velocity, scaled appropriately
        # velocity = state[3]
        # velocity_reward = 0.04 * (velocity  / 7900)  # max reward 0.05
        # # present_reward += velocity_reward


        # # Reward for eccentricity (inverse square, scaled)
        # eccentricity_value = orbital_characteristic[2] + 1  # avoid division by zero
        # eccentricity_reward = 2 / (eccentricity_value ** 2)
        # # present_reward += eccentricity_reward

        # if action == previous_action_list[-1]:
        #     present_reward += 0.00
        # elif action == 1:
        #     present_reward += 0.00
        # else:
        #     self.change_amount  += 1
        #     present_reward -= 0.01 * self.change_amount 



        
        # # present_reward += previous_action_list.count(1)*0.01





        self.total_reward += present_reward
        return present_reward

  def final_reward(self, orbital_characteristic, state):
        '''Reward.final_reward(orbital_characteristic, state) -> float
        adds in the reward for the final orbital characteristic. Return the reward gained by this stage'''
        present_reward = 0

        # if state[7] > math.pi/2:
        #     present_reward -= 200
        # else:

        # Reward for eccentricity (inverse square, scaled)
        eccentricity_value = orbital_characteristic[2] + 1  # avoid division by zero
        # eccentricity_reward = 4 * (10 ** 10) / (eccentricity_value ** 100)
        eccentricity_reward = 6.25 * (10 ** 2) / (eccentricity_value ** 8)
        present_reward += eccentricity_reward

        print(eccentricity_reward)

        # Average height of orbit
        perigee, apogee = orbital_characteristic[:2]
        average_height = (perigee + apogee) / 2

        # Penalty for low perigee
        # if perigee < 100000:
        #     present_reward -= 150  # adjusted penalty
        # else:
        # Reward for average height
        height_reward = perigee * 30 / 230000  # max reward 50
        present_reward += height_reward

        # Additional reward for velocity at final state
        # final_velocity = np.linalg.norm(np.array([state[4], state[5]]))
        # velocity_reward = 130 * (min(final_velocity, 7900) / 7900)**3  # max reward 120
        # present_reward += velocity_reward







        # Scale down final reward to maintain stability
        present_reward *= 0.5

        self.total_reward += present_reward
        return present_reward

  def get_reward(self):
        '''Reward.get_reward() -> float
        returns the amount of reward accumulated in total.'''
        return self.total_reward



# class for rocket launch environment
class Rocket_launch_simulation:
    '''Rocket_launch_simulation is a class that simulates a rocket launch.'''

    def __init__(self, rocket_information, launch_condition):
        '''Rocket_launch_simulation(rocket_information, launch_condition) -> Rocket_launch_simulation
        Initalizes a rocket launch simulation.
        rocket_information is a JSON of the rocket performance.
        launch_condition is a dictionary of the launch conditions.'''
        # get rocket performance infromation
        self.load_rocket_information(rocket_information)

        # load launch condition
        self.launch_inclination = math.radians(launch_condition["inclination"]) # launch orbit inclination

        # enivornment constants
        self.cp = 1004.6851
        self.exp1 = ((self.cp*0.0290) / (8.3145))
        self.L = [-0.0065, 	0.0, 0.001, 0.0028, 	0.0, -0.0028, 	-0.002]
        self.Hb = [0, 11000, 20000, 32000, 470000, 51000, 71000]
        self.Tb = [288.15, 216.65, 216.65, 228.65, 270.65, 270.65, 214.65]
        self.MDb = [1.2250, 0.36391, 0.08803, 0.01322, 0.00143, 0.00086, 0.000064]

        self.mu = (6.6743 * (10 ** -11)) * (5.97219 * (10 ** 24))
        self.radius_earth  = 6371000
        self.earth_rotation_speed = 7.2921159 * 10**-5

        self.reset()



    def load_rocket_information(self, rocket_information):
        '''load_rocket_information(rocket_information) -> None
        sets the rocket performance based on rocket_information JSON'''
        # open the file
        rocket_file = open(rocket_information)

        self.rocket_dictionary = json.load(rocket_file) # load the JSON

        # define the rocket stage names
        self.stage_names = ["Stage " + str(stage_number + 1) for stage_number in range(self.rocket_dictionary["Number of Stages"])]

        # get the pitch rate
        self.pitch_rate = self.rocket_dictionary["Pitch Rate"]

        # Define the thrust and burn rate for each Burn
        for stage_name in self.stage_names:
            isp = self.rocket_dictionary[stage_name]["ISP"]

            # thrust and burn rate list
            self.rocket_dictionary[stage_name]["Burn Rate"] = []
            self.rocket_dictionary[stage_name]["Thrust"] = []

            # get the # of burns
            for burn_number in range(self.rocket_dictionary[stage_name]["Number of Burns"]):
                # get the thrust force and burn rate
                self.rocket_dictionary[stage_name]["Burn Rate"].append(
                    self.rocket_dictionary[stage_name]["Burns Fuel Mass"][burn_number]/self.rocket_dictionary[stage_name]["Burns Time"][burn_number]
                    )

                self.rocket_dictionary[stage_name]["Thrust"].append(isp * 9.8 * self.rocket_dictionary[stage_name]["Burn Rate"][burn_number])









    def thrust(self, time):
        '''Rocket_launch_simulation.thrust(time) -> float
        returns the thrust of the rocket depending on the time'''
        # initalize variables
        deployment_time = self.rocket_dictionary["Deployment Time"]

        # if payload deployed no more thruts
        if time > deployment_time:
            return 0

        total_thrust = 0

        # TBD ################################
        # add booster thrust
        # if haveBooster and time < boosterBurnTime:
        #     total_thrust += boosterFuelMass*9.8*boosterISP*boosterNumber/boosterBurnTime

        # Check which stage is being used at the moment
        for stage_name in self.stage_names:
            if time < self.rocket_dictionary[stage_name]["Seperation Time"]: # operating stage
                # check which burn the rocket is in
                for burn_number in range(self.rocket_dictionary[stage_name]["Number of Burns"]):
                    if time <= self.rocket_dictionary[stage_name]["Burns Start Time"][burn_number] + self.rocket_dictionary[stage_name]["Burns Time"][burn_number] and time > self.rocket_dictionary[stage_name]["Burns Start Time"][burn_number]:
                        return total_thrust + self.rocket_dictionary[stage_name]["Thrust"][burn_number] # add the thrust from main stage and return the thrust
        return 0




    def mass(self, time, height):
        '''Rocket_launch_simulation.mass(time, height) -> float
        returns the mass of the rocket depending on the time and height'''

        # consistent thrust
        total_mass = 0 # total mass of the rocket at this time
        present_stage_name= ""

        # check if deployed the payload
        #add payload mass
        total_mass += self.rocket_dictionary["Payload Mass"]



        if self.rocket_dictionary["Deployment Time"] < time:
            return total_mass # return only payload mass after payload deployment time

        # check if  fairings and escape tower is still on the rocket
        if self.rocket_dictionary["Payload Fairing Seperation Height"] > height:
            total_mass += self.rocket_dictionary["Payload Fairing Mass"]

        if self.rocket_dictionary["Escape Tower Seperation Height"] > height:
            total_mass += self.rocket_dictionary["Escape Tower Mass"]

        # TBD ##########################################################################
        # # booster
        # if haveBooster and time < boosterBurnTime:
        #     boosterFuelRate = boosterFuelMass/boosterBurnTime
        #     totalMass += boosterNumber*(boosterGrossMass - (boosterFuelRate*time))


        # main stages
        for stage_name in self.stage_names:
            if time < self.rocket_dictionary[stage_name]["Seperation Time"]: # stage still on the rocket
                # if the stage is before seperation and is the first stage to be so, it will be the stage which is operating
                if  present_stage_name == "": # doesn't have a defined name
                    present_stage_name = stage_name

                # add the full mass of the stage
                total_mass += self.rocket_dictionary[stage_name]["Empty Mass"] + sum(self.rocket_dictionary[stage_name]["Burns Fuel Mass"])



        # find the amount of fuel that has been burned
        for burn_number in range(self.rocket_dictionary[present_stage_name]["Number of Burns"]):
            # print(self.rocket_dictionary[stage_name]["Burns Start Time"][burn_number])
            # check if the burn is completed
            if time > self.rocket_dictionary[present_stage_name]["Burns Start Time"][burn_number] + self.rocket_dictionary[present_stage_name]["Burns Time"][burn_number]:
                # remove the fuel mass
                total_mass -= self.rocket_dictionary[present_stage_name]["Burns Fuel Mass"][burn_number]
            else:
                # check if the burn has started
                if time >= self.rocket_dictionary[present_stage_name]["Burns Start Time"][burn_number]:
                    # print(self.rocket_dictionary[stage_name]["Burn Rate"][burn_number])
                    total_mass -= (time - self.rocket_dictionary[present_stage_name]["Burns Start Time"][burn_number]) * self.rocket_dictionary[present_stage_name]["Burn Rate"][burn_number]



        # print(preStageNum, remainingMass)
        return total_mass





    def drag(self, velocity, height, g):
        '''Rocket_launch_simulation.drag(velocity, height, g) -> float
        returns the drag of the rocket in this conditon'''
        # into var
        cd0 =  self.rocket_dictionary["Coefficent of Drag"]

        # find Mach velocity (speed of sound)
        mach = 2.340*(10**-17)*(height**4) - 4.897*(10**-12)*(height**3) + 3.227*(10**-7)*(height**2) - 7.276*(10**-3)*height + 346.2

        machNumber = velocity/mach
        # get cd
        cdMain =  cd0*(300**(-((1.1-machNumber)**2))) + 0.01*machNumber + cd0

        # find air density
        bNum = -1
        for index in range(7):
            if (self.Hb[index] < height):
                bNum = index
                break

        if height < 0:
            bNum = 0

        if height > 86000:
            bNum = -1

        # print(bNum)
        if (bNum == -1):
            airDensity = 0
        else:
            airDensity = self.MDb[bNum] * math.exp((-9.80665 * 0.0289644 * (height - self.Hb[bNum])) / (8.3144598 * self.Tb[bNum]))


        # find the drag of main stage
        total_drag = (airDensity * (velocity ** 2) * cdMain * self.rocket_dictionary["Cross Section Area"]) / 2


        # TBD #########################################
        # # booster drag
        # if haveBooster:
        #     # get cd
        #     cdBooster =  cd0Booster*(300**(-((1.1-machNumber)**2))) + 0.01*machNumber + cd0Booster
        #     totalDrag += boosterNumber*(airDensity*(velocity**2)*cdBooster*boosterA)/2


        return total_drag



    def run_an_period(self, run_time, target_pitch_angle, gravity_turn, delta_time = 0.1):
        '''Rocket_launch_simulation.run_an_period(run_time, pitch_angle, gravity_turn, delta_time = 0.1) -> None
        runs the simulation for the given period at the given pitch_angle.'''

        for incrament in range(int(run_time/delta_time)):
            self.time += delta_time

            # use the pitch rate to pitch the rocket
            delta_pitch = target_pitch_angle - self.pitch_angle
            if delta_pitch < 0: # if pitching down
                # check if can reach target pitch angle
                if abs(delta_pitch) < (self.pitch_rate * delta_time):
                    self.pitch_angle = target_pitch_angle
                else:
                    if gravity_turn:
                        # align flight angle and pitch angle
                        if self.flight_angle_space - self.pitch_angle < -self.pitch_rate * delta_time:


                            self.pitch_angle -= self.pitch_rate * delta_time

                        elif self.flight_angle_space - self.pitch_angle > self.pitch_rate * delta_time:
                            self.pitch_angle += self.pitch_rate * delta_time
                        else:
                            self.pitch_angle = self.flight_angle_space
                    else:
                        self.pitch_angle -= self.pitch_rate * delta_time

            else: # pitching up
                # check if can reach target pitch angle
                if abs(delta_pitch) < (self.pitch_rate * delta_time):
                    self.pitch_angle = target_pitch_angle
                else:
                    self.pitch_angle += self.pitch_rate * delta_time



            g = self.mu/((self.radius_earth + self.height) ** 2 ) # gravitaion acceleration

            self.thrust_force = self.thrust(self.time) # thrust

            self.present_mass = self.mass(self.time, self.height) # mass

            drag_force = self.drag(self.total_ground_speed, self.height, g)


            # this is the conversion angle from cartsian to polar
            converstion_angle = self.degree_position - math.pi/2



            # update acceleration
            self.acceleration = np.array([
                (math.cos(self.pitch_angle + converstion_angle) * (self.thrust_force/self.present_mass)) - (math.cos(self.cartesian_flight_angle) * drag_force/self.present_mass ) + (g * math.cos(self.degree_position + math.pi)),
                (math.sin(self.pitch_angle + converstion_angle) * (self.thrust_force/self.present_mass)) - (math.sin(self.cartesian_flight_angle) * drag_force/self.present_mass ) + (g * math.sin(self.degree_position + math.pi))
                ])

            self.total_acceleration = np.linalg.norm(self.acceleration)

            # update ground speed
            self.ground_speed += self.acceleration * delta_time
            self.total_ground_speed = np.linalg.norm(self.ground_speed)


            # update actual speed
            self.speed += self.acceleration * delta_time

            self.total_speed =  np.linalg.norm(self.speed)


            # update position
            self.position += self.speed * delta_time

            # update height
            self.height = np.linalg.norm(self.position) - self.radius_earth

            # update flight angle
            self.cartesian_flight_angle = np.arctan(self.speed[1]/self.speed[0])

            if self.speed[0] < 0:
                self.cartesian_flight_angle += math.pi

            self.flight_angle_space = self.cartesian_flight_angle - converstion_angle



            # update degree position
            if self.position[0] == 0:
                if self.position[1] >= 0: # above x axis
                    self.degree_position = math.pi/2
                else: # below x axis
                    self.degree_position = -math.pi/2
            else:
                self.degree_position = np.arctan(self.position[1]/self.position[0])
                if self.position[0] < 0:
                    self.degree_position += math.pi

            self.degree_position %= 2 * np.pi

            # find polar speed and acceleration
            acceleration_direction =  np.arctan(self.acceleration[1]/self.acceleration[0])

            if self.acceleration[0] < 0:
                acceleration_direction += math.pi

            acceleration_direction -= converstion_angle


            self.polar_acceleration = np.array([math.cos(acceleration_direction),  math.sin(acceleration_direction)]) * self.total_acceleration
            self.polar_speed = np.array([math.cos(self.flight_angle_space),  math.sin(self.flight_angle_space)]) * self.total_speed

            # get the distance from the launch site in terms of the surface of earth
            self.downrange_distance = (self.starting_degree_postion - self.degree_position) * self.radius_earth

            self.downrange_list.append(self.downrange_distance / 1000)

            # save new recording value
            self.time_list.append(self.time)

            self.height_list.append(self.height/1000)

            self.total_acceleration_list.append(self.total_acceleration)
            self.total_speed_list.append(self.total_speed)
            self.speed_list.append(self.speed)

            # self.position_list.append(self.position)
            # print(self.position_list.shape)
            self.position_x_list.append(self.position[0])
            self.position_y_list.append(self.position[1])



            self.mass_list.append(self.present_mass)
            self.thrust_list.append(self.thrust_force)

            self.pitch_angle_list.append(math.degrees(self.pitch_angle))

            self.flight_angle_space_list.append((math.degrees(self.flight_angle_space)+ 90) % 360 - 90)


            # check if hit the ground
            if self.height < 0:
                self.hit_ground = True
                break



    def get_states(self):
        '''Rocekt_launch_simulation.get_states() -> list
        returns an array of the rockets state'''
        return [self.time, self.thrust_force, self.present_mass, self.polar_acceleration[0], self.polar_acceleration[1], self.polar_speed[0], self.polar_speed[1], self.flight_angle_space, self.pitch_angle, self.degree_position, self.height, self.downrange_distance]


    def step(self, target_pitch_angle, gravity_turn):
        '''Rocekt_launch_simulation.step() -> list
        returns the new state given a step'''
        self.run_an_period(0.1, target_pitch_angle, gravity_turn)
        return self.get_states()


    def find_orbital_perameter(self):
        '''Rocekt_launch_simulation.find_orbital_perameter() -> list
        returns the orbits perigee, apogee, and eccentricity.'''

        # find important values
        distance = self.height + self.radius_earth
        h = math.cos(self.flight_angle_space) * self.total_speed*distance


        seni_major_axis = self.mu * distance/((2 * self.mu)-(distance * ((self.total_speed) ** 2)))

        eccentricity = math.sqrt(1 - (h ** 2 * (2 * self.mu - distance * (self.total_speed) ** 2) / (self.mu ** 2 * distance)))

        # calculate perigee and apogee
        perigee = seni_major_axis * (1 - eccentricity) - self.radius_earth
        apogee = seni_major_axis * (1 + eccentricity) - self.radius_earth

        return [perigee, apogee, eccentricity]


    def display_data(self):
        '''Rocekt_launch_simulation.display_data() -> list
        display the data.'''
        figure, axis = plt.subplots(2, 5)

        axis[0,0].plot(self.time_list, self.height_list)
        # axis[0,0].plot(tList, hTestList)
        axis[0,0].set_xlabel('t (s)')
        axis[0,0].set_ylabel('h (km)')
        axis[0,0].legend(['x', 'y'], shadow=True)
        axis[0,0].set_title('Rocket Height')

        axis[0,1].plot(self.time_list, self.total_speed_list)
        axis[0,1].set_xlabel('t (s)')
        axis[0,1].set_ylabel('v (m/s)')
        axis[0,1].legend(['x', 'y'], shadow=True)
        axis[0,1].set_title('Rocket Velocity')

        axis[1,0].plot(self.time_list, self.total_acceleration_list)
        axis[1,0].set_xlabel('t (s)')
        axis[1,0].set_ylabel('a (m/s^2)')
        axis[1,0].legend(['x', 'y'], shadow=True)
        axis[1,0].set_title('Rocket Acceleration')

        axis[1,1].plot(self.time_list, self.thrust_list)
        axis[1,1].set_xlabel('t (s)')
        axis[1,1].set_ylabel('Force (N)')
        axis[1,1].legend(['x', 'y'], shadow=True)
        axis[1,1].set_title('Thrust')

        axis[0,2].plot(self.time_list, self.mass_list)
        axis[0,2].set_xlabel('t (s)')
        axis[0,2].set_ylabel('Mass (kg)')
        axis[0,2].legend(['x', 'y'], shadow=True)
        axis[0,2].set_title('Rocket Mass')

        axis[1,2].plot(self.time_list, self.flight_angle_space_list)
        axis[1,2].set_xlabel('t (s)')
        axis[1,2].set_ylabel('Angle (Deg)')
        axis[1,2].legend(['x', 'y'], shadow=True)
        axis[1,2].set_title('Flight Angle')

        axis[0,3].plot(self.time_list, self.pitch_angle_list)
        axis[0,3].set_xlabel('t (s)')
        axis[0,3].set_ylabel('Angle (Deg)')
        axis[0,3].legend(['x', 'y'], shadow=True)
        axis[0,3].set_title('Pitch Angle')

        #earth

        center = (0, 0)
        radius = self.radius_earth
        circle = Circle(center, radius, color='black', fill=False)

        axis[1,3].set_aspect('equal')
        axis[1,3].add_patch(circle)
        axis[1,3].plot(self.position_x_list, self.position_y_list)
        axis[1,3].set_title('Orbit')


        axis[0,4].plot(self.downrange_list, self.height_list)
        axis[0,4].set_xlabel("Downrange (km)")
        axis[0,4].set_ylabel("Height (km)")
        axis[0,4].set_title('Trajectory')



        plt.show()
       

    def reset(self):
         # initalize simulation variables
        self.time = 0
        self.hit_ground = False

        self.starting_degree_postion = math.pi/2

        self.degree_position = self.starting_degree_postion # this is the angle in the 2D plane of the orbit

        # height
        self.height = 0

        # acceleration
        self.acceleration = np.array([0.0, -self.mu/((self.radius_earth + self.height) ** 2 )])

        self.polar_acceleration = np.array([0.0, -self.mu/((self.radius_earth + self.height) ** 2 )])

        self.total_acceleration = 0

        # initalize the inital speed of the rocket. Factor in earth rotation
        self.speed = np.array([
            (self.earth_rotation_speed * math.cos(self.launch_inclination) * (self.radius_earth + self.height))  * math.cos(self.degree_position - math.pi/2),
            (self.earth_rotation_speed * math.cos(self.launch_inclination) * (self.radius_earth + self.height))  * math.sin(self.degree_position - math.pi/2)
            ])

        self.polar_speed = np.array([
            (self.earth_rotation_speed * math.cos(self.launch_inclination) * (self.radius_earth + self.height))  * math.cos(self.degree_position - math.pi/2),
            (self.earth_rotation_speed * math.cos(self.launch_inclination) * (self.radius_earth + self.height))  * math.sin(self.degree_position - math.pi/2)
            ])

        # ground speed
        self.ground_speed = np.array([0.0, 0.0])

        self.total_ground_speed = 0
        self.total_speed = np.sum(self.speed)

        self.flight_angle_earth = math.pi/2
        self.flight_angle_space = math.pi/2
        self.cartesian_flight_angle = 0.0
        self.pitch_angle =  math.pi/2
        self.height = 0.0
        self.downrange_distance = 0.0
        self.downrange_list = []

        # rocket values

        self.thrust_force = 0.0 # thrust

        self.present_mass = self.mass(0, 0) # mass

        # position
        self.position = np.array([math.cos(self.degree_position) *self.radius_earth, math.sin(self.degree_position) *self.radius_earth])

        # value recording list
        self.position_x_list= []
        self.position_y_list= []
        self.height_list = []
        self.total_acceleration_list = []
        self.speed_list = []
        self.total_speed_list = []
        self.time_list = []
        self.flight_angle_space_list = []
        self.pitch_angle_list = []
        self.degree_position_list = []
        self.thrust_list = []
        self.mass_list = []

        return self.get_states()

    def set_situation(self, values):
         # initalize simulation variables
        self.time = values[0]
        self.hit_ground = False

        self.starting_degree_postion = math.pi/2

        self.degree_position = values[9] # this is the angle in the 2D plane of the orbit

        # height
        self.height = values[10]

        # acceleration
        self.acceleration = np.array([values[3],values[4]])


        # this is the conversion angle from cartsian to polar
        converstion_angle = self.degree_position - math.pi/2


        # find polar speed and acceleration
        acceleration_direction =  np.arctan(self.acceleration[1]/self.acceleration[0])


        self.total_acceleration = np.linalg.norm(self.acceleration)

        if self.acceleration[0] < 0:
            acceleration_direction += math.pi

        acceleration_direction -= converstion_angle


        self.polar_acceleration = np.array([math.cos(acceleration_direction),  math.sin(acceleration_direction)]) * self.total_acceleration


        # initalize the inital speed of the rocket. Factor in earth rotation
        self.speed = np.array([values[5],values[6]])


        self.total_speed = np.linalg.norm(self.speed)


        self.flight_angle_space = values[7]



        self.polar_speed = np.array([math.cos(self.flight_angle_space),  math.sin(self.flight_angle_space)]) * self.total_speed

        # ground speed
        self.ground_speed = np.array([0.0, 0.0])

        self.total_ground_speed = 0

        self.flight_angle_earth = math.pi/2
        self.cartesian_flight_angle = 0.0
        self.pitch_angle =  values[8]


        self.downrange_distance = values[11]
        self.downrange_list = []

        # rocket values

        self.thrust_force = 0.0 # thrust

        self.present_mass = self.mass(self.time, self.height) # mass

        # position
        self.position = np.array([values[12], values[13]])

        # value recording list
        self.position_x_list= []
        self.position_y_list= []
        self.height_list = []
        self.total_acceleration_list = []
        self.speed_list = []
        self.total_speed_list = []
        self.time_list = []
        self.flight_angle_space_list = []
        self.pitch_angle_list = []
        self.degree_position_list = []
        self.thrust_list = []
        self.mass_list = []

        return self.get_states()
    
    def get_pitch_angle(self):
        return self.pitch_angle

file_name = "Desktop/Mehta+_Final_Project/Starship2.json"
env = Rocket_launch_simulation(file_name, {"inclination": 0.453786})

"""# DQN"""

#Replay Buffer From Lunar Lander ---> turns into replay memory in the DNQ agent class

class replay_buffer():
    def __init__(self, buffer_size=10000):
        self.buffer = deque(maxlen=buffer_size)

    def push(self, state, action, reward, next_state, done):
        self.buffer.append((state, action, reward, next_state, done))

    def sample(self, batch_size):
        states, actions, rewards, next_states, dones = zip(*random.sample(self.buffer, batch_size))
        return np.stack(states), actions, rewards, np.stack(next_states), dones

    def __len__(self):
        return len(self.buffer)

#DQN Class
#build a network that gives the expected return for each state
class DQN(nn.Module):
    def __init__(self, state_size = 7, action_size= 3, hidden_size= 128): #might want to define these above the class when u get info
        super(DQN, self).__init__()
        self.layer1 = nn.Linear(state_size, hidden_size)
        self.layer2 = nn.Linear(hidden_size, hidden_size)
        self.layer3 = nn.Linear(hidden_size, hidden_size)
        self.layer4 = nn.Linear(hidden_size, hidden_size)
        self.layer5 = nn.Linear(hidden_size, hidden_size)
        self.layer6 = nn.Linear(hidden_size, hidden_size)
        self.layer7 = nn.Linear(hidden_size, hidden_size)
        self.layer8 = nn.Linear(hidden_size, hidden_size)
        self.layer9 = nn.Linear(hidden_size, hidden_size)
        self.layer10 = nn.Linear(hidden_size, hidden_size)
        self.layer11 = nn.Linear(hidden_size, hidden_size)
        self.layer12 = nn.Linear(hidden_size, hidden_size)
        self.layer13 = nn.Linear(hidden_size, hidden_size)
        self.layer14 = nn.Linear(hidden_size, hidden_size)
        self.layer15 = nn.Linear(hidden_size, hidden_size)
        self.layer16 = nn.Linear(hidden_size, hidden_size)
        self.layer17 = nn.Linear(hidden_size, hidden_size)
        self.layer18 = nn.Linear(hidden_size, hidden_size)
        self.layer19 = nn.Linear(hidden_size, hidden_size)
        self.layer20 = nn.Linear(hidden_size, hidden_size)
        # self.layer21 = nn.Linear(hidden_size, hidden_size)
        # self.layer22 = nn.Linear(hidden_size, hidden_size)
        # self.layer23 = nn.Linear(hidden_size, hidden_size)
        # self.layer24 = nn.Linear(hidden_size, hidden_size)
        # self.layer25 = nn.Linear(hidden_size, hidden_size)
        # self.layer26 = nn.Linear(hidden_size, hidden_size)
        # self.layer27 = nn.Linear(hidden_size, hidden_size)
        # self.layer28 = nn.Linear(hidden_size, hidden_size)
        # self.layer29 = nn.Linear(hidden_size, hidden_size)
        # self.layer30 = nn.Linear(hidden_size, hidden_size)
        # self.layer31 = nn.Linear(hidden_size, hidden_size)
        # self.layer32 = nn.Linear(hidden_size, hidden_size)
        # self.layer33 = nn.Linear(hidden_size, hidden_size)
        # self.layer34 = nn.Linear(hidden_size, hidden_size)
        # self.layer35 = nn.Linear(hidden_size, hidden_size)
        # self.layer36 = nn.Linear(hidden_size, hidden_size)
        # self.layer37 = nn.Linear(hidden_size, hidden_size)
        # self.layer38 = nn.Linear(hidden_size, hidden_size)
        # self.layer39 = nn.Linear(hidden_size, hidden_size)
        # self.layer40 = nn.Linear(hidden_size, hidden_size)
        # self.layer41 = nn.Linear(hidden_size, hidden_size)
        # self.layer42 = nn.Linear(hidden_size, hidden_size)
        # self.layer43 = nn.Linear(hidden_size, hidden_size)
        # self.layer44 = nn.Linear(hidden_size, hidden_size)
        # self.layer45 = nn.Linear(hidden_size, hidden_size)
        # self.layer46 = nn.Linear(hidden_size, hidden_size)
        # self.layer47 = nn.Linear(hidden_size, hidden_size)
        # self.layer48 = nn.Linear(hidden_size, hidden_size)
        # self.layer49 = nn.Linear(hidden_size, hidden_size)
        # self.layer50 = nn.Linear(hidden_size, hidden_size)
        # self.layer51 = nn.Linear(hidden_size, hidden_size)
        # self.layer52 = nn.Linear(hidden_size, hidden_size)
        # self.layer53 = nn.Linear(hidden_size, hidden_size)
        # self.layer54 = nn.Linear(hidden_size, hidden_size)
        # self.layer55 = nn.Linear(hidden_size, hidden_size)
        # self.layer56 = nn.Linear(hidden_size, hidden_size)
        # self.layer57 = nn.Linear(hidden_size, hidden_size)
        # self.layer58 = nn.Linear(hidden_size, hidden_size)
        # self.layer59 = nn.Linear(hidden_size, hidden_size)
        # self.layer60 = nn.Linear(hidden_size, hidden_size)
        # self.layer61 = nn.Linear(hidden_size, hidden_size)
        # self.layer62 = nn.Linear(hidden_size, hidden_size)
        # self.layer63 = nn.Linear(hidden_size, hidden_size)
        # self.layer64 = nn.Linear(hidden_size, hidden_size)
        # self.layer65 = nn.Linear(hidden_size, hidden_size)
        # self.layer66 = nn.Linear(hidden_size, hidden_size)
        # self.layer67 = nn.Linear(hidden_size, hidden_size)
        # self.layer68 = nn.Linear(hidden_size, hidden_size)
        # self.layer69 = nn.Linear(hidden_size, hidden_size)
        # self.layer70 = nn.Linear(hidden_size, hidden_size)
        # self.layer71 = nn.Linear(hidden_size, hidden_size)
        # self.layer72 = nn.Linear(hidden_size, hidden_size)
        # self.layer73 = nn.Linear(hidden_size, hidden_size)
        # self.layer74 = nn.Linear(hidden_size, hidden_size)
        # self.layer75 = nn.Linear(hidden_size, hidden_size)
        # self.layer76 = nn.Linear(hidden_size, hidden_size)
        # self.layer77 = nn.Linear(hidden_size, hidden_size)
        # self.layer78 = nn.Linear(hidden_size, hidden_size)
        # self.layer79 = nn.Linear(hidden_size, hidden_size)
        # self.layer80 = nn.Linear(hidden_size, hidden_size)
        # self.layer81 = nn.Linear(hidden_size, hidden_size)
        # self.layer82 = nn.Linear(hidden_size, hidden_size)
        # self.layer83 = nn.Linear(hidden_size, hidden_size)
        # self.layer84 = nn.Linear(hidden_size, hidden_size)
        # self.layer85 = nn.Linear(hidden_size, hidden_size)
        # self.layer86 = nn.Linear(hidden_size, hidden_size)
        # self.layer87 = nn.Linear(hidden_size, hidden_size)
        # self.layer88 = nn.Linear(hidden_size, hidden_size)
        # self.layer89 = nn.Linear(hidden_size, hidden_size)
        # self.layer90 = nn.Linear(hidden_size, hidden_size)
        self.final_layer = nn.Linear(hidden_size, action_size)

    def forward(self, state):
        state = F.relu(self.layer1(state))
        state = F.relu(self.layer2(state))
        state = F.relu(self.layer3(state))
        state = F.relu(self.layer4(state))
        state = F.relu(self.layer5(state))
        state = F.relu(self.layer6(state))
        state = F.relu(self.layer7(state))
        state = F.relu(self.layer8(state))
        state = F.relu(self.layer9(state))
        state = F.relu(self.layer10(state))
        state = F.relu(self.layer11(state))
        state = F.relu(self.layer12(state))
        state = F.relu(self.layer13(state))
        state = F.relu(self.layer14(state))
        state = F.relu(self.layer15(state))
        state = F.relu(self.layer16(state))
        state = F.relu(self.layer17(state))
        state = F.relu(self.layer18(state))
        state = F.relu(self.layer19(state))
        state = F.relu(self.layer20(state))
        # state = F.relu(self.layer21(state))
        # state = F.relu(self.layer22(state))
        # state = F.relu(self.layer23(state))
        # state = F.relu(self.layer24(state))
        # state = F.relu(self.layer25(state))
        # state = F.relu(self.layer26(state))
        # state = F.relu(self.layer27(state))
        # state = F.relu(self.layer28(state))
        # state = F.relu(self.layer29(state))
        # state = F.relu(self.layer30(state))
        # state = F.relu(self.layer31(state))
        # state = F.relu(self.layer32(state))
        # state = F.relu(self.layer33(state))
        # state = F.relu(self.layer34(state))
        # state = F.relu(self.layer35(state))
        # state = F.relu(self.layer36(state))
        # state = F.relu(self.layer37(state))
        # state = F.relu(self.layer38(state))
        # state = F.relu(self.layer39(state))
        # state = F.relu(self.layer40(state))
        # state = F.relu(self.layer41(state))
        # state = F.relu(self.layer42(state))
        # state = F.relu(self.layer43(state))
        # state = F.relu(self.layer44(state))
        # state = F.relu(self.layer45(state))
        # state = F.relu(self.layer46(state))
        # state = F.relu(self.layer47(state))
        # state = F.relu(self.layer48(state))
        # state = F.relu(self.layer49(state))
        # state = F.relu(self.layer50(state))
        # state = F.relu(self.layer51(state))
        # state = F.relu(self.layer52(state))
        # state = F.relu(self.layer53(state))
        # state = F.relu(self.layer54(state))
        # state = F.relu(self.layer55(state))
        # state = F.relu(self.layer56(state))
        # state = F.relu(self.layer57(state))
        # state = F.relu(self.layer58(state))
        # state = F.relu(self.layer59(state))
        # state = F.relu(self.layer60(state))
        # state = F.relu(self.layer61(state))
        # state = F.relu(self.layer62(state))
        # state = F.relu(self.layer63(state))
        # state = F.relu(self.layer64(state))
        # state = F.relu(self.layer65(state))
        # state = F.relu(self.layer66(state))
        # state = F.relu(self.layer67(state))
        # state = F.relu(self.layer68(state))
        # state = F.relu(self.layer69(state))
        # state = F.relu(self.layer70(state))
        # state = F.relu(self.layer71(state))
        # state = F.relu(self.layer72(state))
        # state = F.relu(self.layer73(state))
        # state = F.relu(self.layer74(state))
        # state = F.relu(self.layer75(state))
        # state = F.relu(self.layer76(state))
        # state = F.relu(self.layer77(state))
        # state = F.relu(self.layer78(state))
        # state = F.relu(self.layer79(state))
        # state = F.relu(self.layer80(state))
        # state = F.relu(self.layer81(state))
        # state = F.relu(self.layer82(state))
        # state = F.relu(self.layer83(state))
        # state = F.relu(self.layer84(state))
        # state = F.relu(self.layer85(state))
        # state = F.relu(self.layer86(state))
        # state = F.relu(self.layer87(state))
        # state = F.relu(self.layer88(state))
        # state = F.relu(self.layer89(state))
        # state = F.relu(self.layer90(state))
        return self.final_layer(state)
#
def plot_reward_change(scores):
  figure, axis = plt.subplots(1, 2)


  axis[0].plot(list(range(len(scores))), scores)
  axis[0].set_ylabel('The Total Reward')
  axis[0].legend(['x', 'y'], shadow=True)
  axis[0].set_title('Total Reward')


  axis[1].hist(scores, bins = 20)
  plt.show()
 
  
def plot_orbital_param(perigee_list, ecen_list):
  figure, axis = plt.subplots(1, 2)


  axis[0].plot(list(range(len(perigee_list))), perigee_list)
  axis[0].set_ylabel('Height m')
  axis[0].legend(['x', 'y'], shadow=True)
  axis[0].set_title('perigee')


  axis[1].plot(list(range(len(ecen_list))), ecen_list)
  axis[1].legend(['x', 'y'], shadow=True)
  axis[1].set_title('Ecen')


  plt.show()

"""# Train"""


#Train the agent

def Run_model(model, total_run_time = 150*600, run_length = 100):
    '''
    Train a DQN agent.

    Parameters
    ----------
    agent: DQNAgent
        The agent to be trained.
    n_episodes: int, default=2000
        The number of episodes for which to train the agent.
    eps_start: float, default=1.0
        The starting epsilon for epsilon-greedy action selection.
    eps_end: float, default=0.01
        The minimum value that epsilon can reach.
    eps_decay: float, default=0.995
        The decay rate for epsilon after each episode.
    target_update: int, default=10
        The frequency (number of episodes) with which the target network should be updated.

    Returns
    -------
    list of float
        The total reward obtained in each episode.
    '''




    start_value = 4560 - run_length

        # Reset environment and score at the start of each episode
    present_pitch_angle =  present_state[start_value][8]
    # state = [state[0]] + state[4:7] + [state[8]]

    # Loop over steps
    previous_pitch_angle_target = math.radians(90)
    present_pitch_angle_target = math.radians(90)
    change_pitch_angle = 0

    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    state = env.set_situation(present_state[4560-200])
    for time in range(4560-200 + 1, start_value + 1):
        state = env.step(0, False)

        
    state = state[0:3] + state[5:7] + [state[10]] + [env.find_orbital_perameter()[2]]



    for time in range(start_value + 1, total_run_time):  # this just how much iteration we are going to do for now. This is 456.1 seconds, the rocket completes the burn at 456 secondd
        present_pitch_angle = round(env.get_pitch_angle(), 4)

        if time < 4562:

          # Select an action using current agent policy then apply in environment

          
          # Convert state to a PyTorch tensor and set network to evaluation mode
          state = torch.from_numpy(np.array(state)).float().unsqueeze(0).to(device)

          # With no gradient updates, get the action values from the DQN
          with torch.no_grad():
              action_values = model(state)


          action = np.argmax(action_values.cpu().data.numpy())
          # if random.random() > eps:
          #     action = agent.act(np.array(state), 0)
          # else:
          #     if present_pitch_angle_target == present_pitch_angle:
          #         action = 1
          #     elif  present_pitch_angle_target < present_pitch_angle:
          #         action = 0
          #     else:
          #         action = 2
              

          previous_pitch_angle_target = present_pitch_angle_target
          # make sure action make sense
          change_pitch_angle = pitch_angle_reference_angle[action]
        else:
          change_pitch_angle = 0


        next_state = env.step(present_pitch_angle + change_pitch_angle, False)

        present_orbital_param = env.find_orbital_perameter()
        # remove extra states
        next_state =  next_state[0:3] + next_state[5:7] + [next_state[10]] + [present_orbital_param[2]]

        # next_state = [next_state[0]] + next_state[4:7] + [next_state[8]]


        done = time == 4561

        if done:
            print(present_orbital_param)


        # find the reward
        # Update the agent, state and score
        state = next_state

        



    # env.display_data()

    return env.time_list, env.position_x_list, env.position_y_list, env.height_list, env.pitch_angle_list
    

def load_model(filepath):
    model_path = torch.load(filepath)
    model = model_path['model']
    model.load_state_dict(model_path['state_dict'])
    for parameter in model.parameters():
        parameter.requires_grad = False

    model.eval() ##super important
    return model


model = load_model('model072313SH.pth')


time_list_MO, positionX_MO, positionY_MO, height_list_MO, pitch_angle_listMO = Run_model(model)


model = load_model('model20-072314SH.pth')


time_list_MO1, positionX_MO1, positionY_MO1, height_list_MO1, pitch_angle_list_MO1 = Run_model(model, run_length = 200)



# get regular values
start_value = 4560 - 200
state = env.set_situation(present_state[start_value])
for time in range(start_value + 1, 150*600):
  env.step(0, False)

time_list_OG, positionX_OG, positionY_OG, height_list_OG, pitch_angle_list_OG = env.time_list, env.position_x_list, env.position_y_list, env.height_list, env.pitch_angle_list

 #earth

center = (0, 0)
radius = env.radius_earth
circle = Circle(center, radius, color='black', fill=False)

fig = plt.figure()
ax = fig.gca()

ax.add_patch(circle)
ax.plot(positionX_OG, positionY_OG, label="Orignial")
ax.plot(positionX_MO, positionY_MO, 'g--', label="10-Second Optimization")
ax.plot(positionX_MO1, positionY_MO1, '--', label="20-Second Optimization")
ax.set_axis_off()
ax.set_aspect('equal')
ax.set_title('Final Orbit')
ax.legend(loc='upper right')
plt.show()


plt.plot(time_list_OG, height_list_OG, label="Orignial")
plt.plot(time_list_MO, height_list_MO, 'g--', label="10-Second Optimization")
plt.plot(time_list_MO1, height_list_MO1, '--', label="20-Second Optimization")
plt.title('Orbital Height to Time')
plt.ylabel('Height (km)')
plt.xlabel('Time (s)')
plt.legend(loc='upper right')
plt.show()


plt.plot(time_list_OG[:200], pitch_angle_list_OG[:200], label="Orignial")
plt.plot(time_list_MO[:200], pitch_angle_listMO[:200], 'g--', label="10-Second Optimization")
plt.plot(time_list_MO1[:200], pitch_angle_list_MO1[:200], '--', label="20-Second Optimization")
plt.title('Pitch Angle to Time')
plt.ylabel('Angle (°)')
plt.xlabel('Time (s)')
plt.legend(loc='lower left')
plt.show()